{"version":3,"sources":["mapGen/gridTile.ts","util/calculations.ts","mapGen/mapGrid.ts","util/weights.ts","dataStructs/priorityQueue.ts","index.jsx","pathFinding/aStar.ts"],"names":["tileType","Tile","x","y","type","xChord","yChord","this","regular","chords","hard","setType","hardHighway","regularHighway","newTile","blocked","path","start","end","distance","a","b","Math","sqrt","direction_t","moveCase","Grid","map","i","Array","j","push","genHardCells","genHighWays","genBlockCells","genPoint","setPoints","rowString","getTileChar","console","log","regionsCount","floor","random","xStart","yStart","xEnd","yEnd","tile","dir","getChords","undefined","xCur","yCur","down","left","up","right","boundary","directionMoving","none","HEIGHT","WIDTH","curTile","count","highwayLength","setToHighway","nextTile","walkHighwayGen","getType","direction","outbounds","mapCopy","clone","tries","oldMap","copyGrid","genHighWay","cellsToBlock","tempTile","filter","length","forEach","neighbors","QueElement","element","f","parent","g","h","PriorityQueue","que","item","priority","queMember","inQue","splice","isEmpty","elm","slice","isDiag","from","to","moveCost","canMoveTo","cost","fromType","toType","regReg","regHard","regRhigh","regHhigh","hardHard","hardRhigh","hardHhigh","rhRh","rhHh","hhHh","error","moveType","Square","className","style","background","React","Component","Game","props","state","maps","pathFound","current","findPath","bind","nextMap","previousMap","curMap","grid","fringe","visited","getStart","getEnd","enqueue","currentTile","pop","reverse","getNeighbors","neighbor","indexOf","gScore","inFringe","oldElm","getElm","newHVal","newQueElm","addQueElm","aStar","updateForPath","setState","printMap","rows","entry","onClick","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.93409ab8.chunk.js","sourcesContent":["export enum tileType { \n    blocked,\n    regular,\n    hard,\n    regularHighway,\n    hardHighway,\n    path,\n    start,\n    end,\n}\n\nexport class Tile {\n    xChord: number;\n    yChord: number;\n    type: tileType;\n\n    constructor(x:number, y:number, type?:tileType ){\n        this.xChord = x;\n        this.yChord = y;\n        this.type = type || tileType.regular;\n    }\n\n    setType(type:tileType) {\n        this.type = type;\n    }\n\n    getType() : tileType {\n        return this.type;\n    }\n\n    getChords(): number[] {\n        let chords = [2];\n        chords[0] = this.xChord;\n        chords[1] = this.yChord;\n\n        return chords;\n    }\n\n    setToHighway() {\n        if(this.type === tileType.hard) {\n            this.setType(tileType.hardHighway);\n        } \n        else if (this.type === tileType.regular) {\n            this.setType(tileType.regularHighway);\n        }\n    }\n\n    clone() : Tile {\n        let newTile = new Tile(this.xChord, this.yChord);\n        newTile.type = this.type;\n  \n        return newTile;\n    }\n\n    getTileChar() { \n        switch(this.type){\n            case tileType.blocked: return ' ';\n            case tileType.regular: return ' ';\n            case tileType.hard: return ' ';\n            case tileType.regularHighway: return ' ';\n            case tileType.hardHighway: return ' ';\n            case tileType.path: return '>';\n            case tileType.start: return 'S';\n            case tileType.end: return 'E';\n            default: return '!'\n        }\n    }\n\n}","export function distance(a:number[], b:number[]): number {\n    let x:number = a[0] - b[0];\n    let y:number = a[1] - b[1];\n\n    return Math.sqrt(x*x + y*y);\n\n}","import { Tile, tileType } from \"./gridTile\";\nimport { distance } from \"../util/calculations\"\n\nlet WIDTH:number = 160;\nlet HEIGHT:number = 120;\nlet HIGHWAYSIZE:number = 20;\nlet HIGHWAYCOUNT:number = 5;\n\nenum direction_t { \n    none,\n    down,\n    right,\n    up,\n    left,\n    outbounds\n}\n\n\n\nexport class Grid {\n    map:Tile[][];\n    start:number[];\n    end:number[];\n\n    constructor() {\n        this.map = [];\n        for(let i = 0; i < HEIGHT; ++i){\n            this.map[i] = new Array();\n            for(let j = 0; j < WIDTH; ++j){\n                this.map[i].push(new Tile(j, i));\n            }\n        }\n        this.genHardCells();\n        this.genHighWays();\n        this.genBlockCells();\n\n        this.start = this.genPoint();\n        this.end =this.genPoint();\n        while(distance(this.start, this.end) < 100){\n            this.start = this.genPoint();\n            this.end =this.genPoint();\n        }\n\n        this.setPoints();\n    }\n\n    \n    printMap(){\n        // build each rows sting\n        let rowString: string = \"\";\n        for (let i = 0; i < HEIGHT; ++i){\n            for (let j = 0; j < WIDTH; ++j){\n                if(i == this.start[1] && j === this.start[0]){\n                    rowString +='S';\n                }\n                else if(i == this.end[1] && j === this.end[0]){\n                    rowString += 'E';\n                }\n                else {\n                    rowString += this.map[i][j].getTileChar();\n                }\n            }\n            console.log(rowString);\n            rowString = \"\";\n        }\n        console.log();\n    }\n\n    genHardCells() {\n        for (let regionsCount:number = 0; regionsCount < 8; ++regionsCount) {\n            let xChord:number = Math.floor((Math.random() * WIDTH));\n            let yChord:number = Math.floor((Math.random() * HEIGHT));\n            let xStart:number = (xChord-16 > 0 ? (xChord-16) : 0);\n            let yStart:number = (yChord-16 > 0 ? (yChord-16) : 0);\n            let xEnd:number = (xChord+16 < WIDTH ? (xChord+16) : WIDTH);\n            let yEnd:number = (yChord+16 < HEIGHT ? (yChord+16) : HEIGHT);\n\n            console.log(\"xStart:\" + xStart + \" xEnd:\" + xEnd + \" yStart:\" + yStart + \" yEnd:\" + yEnd);\n\n            for(let i = yStart; i < yEnd; ++i) {\n                for(let j = xStart; j < xEnd; ++j){\n                    let chance = Math.floor(Math.random() * 2);\n                    if(chance === 1){//make tile hard\n                        this.map[i][j].setType(tileType.hard);\n                    }\n                }\n            }\n        }\n    }\n\n    walkHighwayGen (tile:Tile, dir:direction_t) : Tile{\n\n        \n        let newTile:Tile = tile;\n        let chords:number[] = tile.getChords();\n        \n        if(tile === undefined){\n            console.log();\n            console.log(\"ded\");\n            console.log();\n            return newTile;\n        }\n\n        //console.log(\"got CHords\");\n        let xCur = chords[0];\n        let yCur = chords[1];\n        //console.log(\"read CHords\");\n\n        switch(dir){ \n            case direction_t.down: {\n                if(yCur + 1 >= HEIGHT){\n                    console.log(\"Over height\");\n                    return tile;\n                }\n                yCur++;\n                break;\n            }\n            case direction_t.left: {\n                if(xCur + 1 >= WIDTH){\n                    console.log(\"Over width\");\n                    return tile;\n                }\n                xCur++;\n                break;\n            }\n            case direction_t.up: {\n                if(yCur - 1 < 0){\n                    console.log(\"under height\");\n                    return tile;\n                }\n                yCur--;\n                break;\n            }\n            case direction_t.right: {\n                if(xCur - 1 < 0){\n                    console.log(\"under width\");\n                    return tile;\n                }\n                xCur--;\n                break;\n            }\n            default: \n                console.log(\"walking is wrong\");\n                return tile;\n        }\n\n        //console.log(\"setting new tile\");\n        //console.log(\"x: \" + xCur + \" y: \" + yCur);\n        if(this.map[yCur] === undefined){\n            console.log(\"map undefiend\");\n            return tile;\n        }\n        newTile = this.map[yCur][xCur];\n        //console.log(\"updated new tile\");\n        if(newTile === undefined){\n            console.log();\n            console.log(\"null tile ref\");\n            console.log(\"last tile chords: \" + tile.getChords());\n            console.log(\"new Chords: \" + xCur + \",\" + yCur);\n            console.log(\"dir: \" + dir);\n            console.log();\n            return tile;\n        }\n        //console.log(\"new tile: \" + newTile.getChords());\n        return newTile;\n    }\n\n    genHighWay(): boolean {\n        //console.log();\n        //console.log(\"generating Highways\")\n        //console.log();\n        \n        //pick a boundary, starting top clockwise;\n        let boundary:number = Math.floor(Math.random() * 4);\n        let xStart:number = 0;\n        let yStart:number = 0;\n        let directionMoving = direction_t.none;\n\n        if(boundary%2 === 0){ //top or bottom\n            xStart = Math.floor(Math.random() * WIDTH);\n            if(boundary === 0){\n                yStart = 0;\n                directionMoving = direction_t.down;\n            }\n            else {\n                yStart = HEIGHT-1;\n                directionMoving = direction_t.up;\n            }\n        }\n        else {\n            yStart = Math.floor(Math.random() * HEIGHT);\n            if(boundary === 1){\n                xStart = 0;\n                directionMoving = direction_t.left;\n            }\n            else {\n                xStart = WIDTH-1;\n                directionMoving = direction_t.right;\n            }\n        }\n\n        //console.log(\"xStart:\" + xStart +  \" yStart:\" + yStart);\n        let y:number = yStart;\n        let x:number = xStart;\n        let curTile:Tile = this.map[y][x];\n        //console.log(\"got curr tile\");\n        for(let count:number = 0; count < 5; ++count) {\n            for(let highwayLength:number = 0; highwayLength < 20; ++highwayLength) {\n                curTile.setToHighway();\n                //console.log(\"updated type\");\n                //console.log(\"current tile: \" + curTile.getChords());\n                //while(curTile.getType() === tileType.regularHighway || curTile.getType() === tileType.hardHighway){\n                        //get new direction\n                \n                    //console.log(\"walking tile\");\n                    let nextTile:Tile = this.walkHighwayGen(curTile, directionMoving);\n                    //console.log(\"walked tile\");\n                    if(nextTile === undefined || nextTile === curTile){\n                        console.log();\n                        console.log(\"newTile bad \");\n                        console.log();\n                        return false; \n                    }\n                    if(nextTile.getType() === tileType.regularHighway || nextTile.getType() === tileType.hardHighway)\n                        return false;\n                    //console.log(\"updating curTile\");\n                    curTile = nextTile;\n                //}\n            }\n\n            let direction:number = Math.floor(Math.random() * 10);\n\n            if(direction < 6) {\n                // continue onwards\n            }\n            else {\n                //perpindicular\n                let turn:number = Math.floor(Math.random() * 2);\n                if(turn === 0) {\n                    //left\n                    directionMoving--;\n                }\n                else {\n                    //right\n                    directionMoving++;\n                }\n\n                //correct enum\n                if(directionMoving === direction_t.none ){\n                    directionMoving = direction_t.left;\n                }\n                if(directionMoving === direction_t.outbounds) {\n                    direction = direction_t.down;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    copyGrid(map:Tile[][]): Tile[][] {\n        let mapCopy:Tile[][] = [];\n\n        for (let i:number = 0; i < HEIGHT; ++i){\n            mapCopy[i] = new Array();\n            for (let j:number = 0; j < WIDTH; ++j){\n                mapCopy[i].push(map[i][j].clone());\n            }\n        }\n\n        return mapCopy;\n    }\n\n    genHighWays() : boolean {\n        let tries:number = 0;\n        let count:number = 0\n        while(tries <  20  && count < HIGHWAYCOUNT){\n           //console.log();\n           // console.log(\"highway attempts failed:\" + tries);\n            //console.log(\"highway attempts passed:\" + count);\n            //console.log();\n            let oldMap:Tile[][] = this.copyGrid(this.map);\n\n            let success:boolean = this.genHighWay(); \n            if(success){\n                //console.log();\n                //console.log(\"highway sucsessfull\");\n                //console.log();\n                count++;\n                //this.printMap();\n            }\n            else{\n                this.map = oldMap;\n                //console.log();\n                //console.log(\"highway failed\");\n                //console.log();\n                tries++;\n            }\n        }\n\n\n        return true;\n    }\n\n    genBlockCells(){\n        let cellsToBlock:Tile[] = [];\n\n        while (cellsToBlock.length < Math.floor((HEIGHT*WIDTH) * .2)){\n            let xChord = Math.floor(Math.random() * WIDTH);\n            let yChord = Math.floor(Math.random() * HEIGHT);\n\n            let tempTile = this.map[yChord][xChord];\n            if(!(cellsToBlock.filter(tile => (tile.xChord === tempTile.xChord && tile.yChord === tempTile.yChord)).length > 0) &&\n                    (tempTile.type !== tileType.hardHighway && tempTile.type !== tileType.regularHighway)){\n                cellsToBlock.push(tempTile);\n            }\n        }\n\n        cellsToBlock.forEach( tile => tile.setType(tileType.blocked));\n\n        \n    }\n\n    genPoint(): number[] {\n        \n\n        let x = Math.floor(Math.random() * WIDTH);\n        let y = Math.floor(Math.random() * HEIGHT);\n\n        while( !(x < 20 || x > WIDTH-21) &&\n                !(y<20 || y > HEIGHT - 21)) {\n\n            x = Math.floor(Math.random() * WIDTH);\n            y = Math.floor(Math.random() * HEIGHT);\n        }\n\n\n        return [x, y];\n    }\n\n    getNeighbors(chords:number[] ): Tile[] {\n        if (chords.length < 2)\n            return [];\n\n        let neighbors = []\n        let xStart = (chords[0] -1) < 0 ? 0 : (chords[0] -1);\n        let yStart = (chords[1] -1) < 0 ? 0 : (chords[1] -1);\n\n        let yEnd = (yStart + 3) <= HEIGHT ? (yStart + 3) : HEIGHT -1;\n        let xEnd = (xStart + 3) <= WIDTH ? (xStart + 3) : WIDTH -1;\n        console.log(xStart, yStart, xEnd, yEnd);\n        for(let i = yStart; i < yEnd; ++i){\n            for(let j = xStart; j < xEnd; ++j){\n\n                //console.log(\"pull current chords\");\n                //console.log(\"tile chords: \" + chords[0]+ ' ' + chords[1] , j, i);\n                //console.log(\"not  tile? :\" + !(j === chords[0] && i === chords[1]))\n                if(!(j === chords[0] && i === chords[1])) { //not the same tile\n                    //console.log(\"add neighbors\")\n                    //console.log(j, i);\n                    let tile:Tile = this.map[i][j];\n                    if(tile.getType() !== tileType.blocked)\n                        neighbors.push(this.map[i][j]);\n                }\n            }\n        }\n        //console.log(\"neigbors are: \");\n        //console.log(neighbors);\n        return neighbors;\n    }\n\n    getStart():Tile {\n        return this.map[this.start[1]][this.start[0]];\n    }\n\n    getEnd():Tile {\n        return this.map[this.end[1]][this.end[0]];\n    }\n\n    updateForPath(path:Tile[]) {\n        for(let i:number = 0; i < path.length; i++){\n            let chords:number[] = path[i].getChords();\n            this.map[chords[1]][chords[0]].setType(tileType.path);\n        }\n    }\n\n    setPoints() {\n        this.map[this.start[1]][this.start[0]].setType(tileType.start);\n        this.map[this.end[1]][this.end[0]].setType(tileType.end);\n    }\n    \n}","import { Tile, tileType } from \"../mapGen/gridTile\";\n\nenum moveCase {\n    regReg,\n    regHard,\n    regRhigh,\n    regHhigh,\n    hardHard,\n    hardRhigh,\n    hardHhigh,\n    rhRh,\n    rhHh,\n    hhHh,\n    error,\n}\n\nfunction isDiag(from:Tile, to:Tile) : boolean {\n    return !(from.xChord === to.xChord || from.yChord === to.yChord);\n}\n\nfunction canMoveTo(to:Tile) : boolean {\n    return (to.getType() !== tileType.blocked);\n}\n\n\nfunction moveType(from:Tile, to:Tile) : moveCase {\n    let fromType:tileType = from.getType();\n    let toType:tileType = to.getType();\n\n    if(fromType === tileType.regular){\n        if(toType === tileType.regular){\n            return moveCase.regReg\n        }\n        else if(toType === tileType.hard){\n            return moveCase.regHard\n        }\n        else if(toType === tileType.regularHighway){\n            return moveCase.regRhigh;\n        } \n        else if(toType === tileType.hardHighway){\n            return moveCase.regHhigh;\n        }\n\n    }\n    else if(fromType === tileType.hard){\n        if(toType === tileType.regular){\n            return moveCase.regHard\n        }\n        else if(toType === tileType.hard){\n            return moveCase.hardHard;\n        }\n        else if(toType === tileType.regularHighway){\n            return moveCase.hardRhigh;\n        } \n        else if(toType === tileType.hardHighway){\n            return moveCase.hardHhigh;\n        }\n\n    }\n    else if(fromType === tileType.regularHighway){\n        if(toType === tileType.regular){\n            return moveCase.regRhigh;\n        }\n        else if(toType === tileType.hard){\n            return moveCase.hardRhigh;\n        }\n        else if(toType === tileType.regularHighway){\n            return moveCase.rhRh;\n        } \n        else if(toType === tileType.hardHighway){\n            return moveCase.rhHh;\n        }\n\n    } \n    else if(fromType === tileType.hardHighway){\n        if(toType === tileType.regular){\n            return moveCase.regHhigh;\n        }\n        else if(toType === tileType.hard){\n            return moveCase.hardHhigh;\n        }\n        else if(toType === tileType.regularHighway){\n            return moveCase.rhHh;\n        } \n        else if(toType === tileType.hardHighway){\n            return moveCase.hhHh;\n        }\n\n    }\n\n    return moveCase.error;\n}\n\n\nexport function moveCost(from:Tile, to:Tile) : number {\n    if(!canMoveTo(to)){\n        console.log(\"cant move to blocked tile\");\n        return -1;\n    }\n\n    let cost = 0;\n    let fromType:tileType = from.getType();\n    let toType:tileType = to.getType();\n    let move:moveCase = moveType(from, to);\n\n        switch(move) {\n            case moveCase.regReg: {\n                if(isDiag(from, to)){\n                    cost = Math.sqrt(2)\n                }\n                else{\n                    cost = 1;\n                }\n\n                break;\n            }\n            case moveCase.regHard: {\n                if(isDiag(from, to)){\n                    cost = (Math.sqrt(2) + Math.sqrt(8))/2;\n                }\n                else{\n                    cost = 1.5;\n                }\n\n                break;\n            }\n            case moveCase.regRhigh: {\n                if(isDiag(from, to)){\n                    cost = Math.sqrt(2)\n                }\n                else{\n                    cost = 1;\n                }\n\n                break;\n            }\n            case moveCase.regHhigh: {\n                if(isDiag(from, to)){\n                    cost = (Math.sqrt(2) + Math.sqrt(8))/2;\n                }\n                else{\n                    cost = 1.5;\n                }\n\n                break;\n            }\n            case moveCase.hardHard: {\n                if(isDiag(from, to)){\n                    cost = Math.sqrt(8)\n                }\n                else{\n                    cost = 2;\n                }\n\n                break;\n            }\n            case moveCase.hardRhigh: {\n                if(isDiag(from, to)){\n                    cost = (Math.sqrt(2) + Math.sqrt(8))/2;\n                }\n                else{\n                    cost = 1.5;\n                }\n\n                break;\n            }\n            case moveCase.hardHhigh: {\n                if(isDiag(from, to)){\n                    cost = Math.sqrt(8)\n                }\n                else{\n                    cost = 2;\n                }\n\n                break;\n            }\n            case moveCase.rhRh: {\n                if(isDiag(from, to)){\n                    cost = Math.sqrt(2)/4\n                }\n                else{\n                    cost = 1/4;\n                }\n\n                break;\n            }\n            case moveCase.rhHh: {\n                if(isDiag(from, to)){\n                    cost = (Math.sqrt(2) + Math.sqrt(8))/2/4;\n                }\n                else{\n                    cost = 1.5/4;\n                }\n\n                break;\n            }\n            case moveCase.hhHh: {\n                if(isDiag(from, to)){\n                    cost = Math.sqrt(8)/4\n                }\n                else{\n                    cost = 2/4;\n                }\n\n                break;\n            }\n            default :\n            console.log(\"moveCases are wrong\");\n            return -1;\n        }\n\n        \n\n\n    return cost;\n\n}","import { Tile, tileType } from \"../mapGen/gridTile\"\n\nexport class QueElement {\n    element:Tile;\n    f:number;\n    g:number;\n    h:number;\n    parent:QueElement | null;\n\n    constructor(element:Tile, f:number, parent?:QueElement) {\n        this.element = element;\n        this.f = f;\n        this.h = 0;\n        this.g = 0;\n        this.parent = parent ||  null;\n    }\n}\n\nexport class PriorityQueue {\n    que:QueElement[];\n\n    constructor() {\n        this.que = [];\n    }\n\n    enqueue(item:Tile, priority:number) {\n\n        let queMember:QueElement = new QueElement(item, priority);\n        let inQue:boolean = false;\n\n        for(let i:number = 0; i < this.que.length; ++i){\n            if(this.que[i].f > queMember.f){\n                this.que.splice(i, 0, queMember);\n                inQue = true;\n                break;\n            }\n        }\n\n        if(!inQue) {\n            this.que.push(queMember);\n        }\n\n    }\n\n    addQueElm(queMember:QueElement){\n        let inQue:boolean = false;\n\n        for(let i:number = 0; i < this.que.length; ++i){\n            if(this.que[i].f > queMember.f){\n                this.que.splice(i, 0, queMember);\n                inQue = true;\n                break;\n            }\n        }\n\n        if(!inQue) {\n            this.que.push(queMember);\n        }\n\n    }\n\n    pop() : QueElement | null{\n        if(!this.isEmpty()){\n            let elm = this.que[0];\n            this.que = this.que.slice(1);\n            return elm;\n        }\n\n        return null;\n    }\n\n    remove(item:Tile) : boolean{\n        for(let i:number = 0; i < this.que.length; ++i){\n            if(this.que[i].element === item){\n                this.que.splice(i, i+1);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    isEmpty() : boolean {\n\n        return this.que.length > 0 ? false : true;\n    }\n    \n    inFringe(tile:Tile) : boolean {\n        for(let i:number = 0; i < this.que.length; ++i){\n            if(this.que[i].element === tile){\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    getElm(tile:Tile) :QueElement | null{\n        let elm:QueElement| null = null;\n        for(let i:number = 0; i < this.que.length; ++i){\n            if(this.que[i].element === tile){\n                elm = this.que[i];\n            }\n        }\n        return elm;\n    }\n\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { Grid, HEIGHT, WIDTH } from \"./mapGen/mapGrid.ts\"\nimport { Tile, tileType } from \"./mapGen/gridTile\"\nimport { aStar } from \"./pathFinding/aStar\"\n\nfunction Square(type) {\n    switch(type){\n        case tileType.blocked: return <td className=\"square\" style={{background: \"black\"}}/>;\n        case tileType.regular: return <td className=\"square\" style={{background: \"blue\"}}/>;\n        case tileType.hard: return <td className=\"square\" style={{background: \"green\"}}/>;\n        case tileType.regularHighway: return <td className=\"square\" style={{background: \"white\"}}/>;\n        case tileType.hardHighway: return <td className=\"square\" style={{background: \"grey\"}}/>;\n        case tileType.path: return <td className=\"square\" style={{background: \"pink\"}}/>;\n        case tileType.start: return <td className=\"square\" style={{background: \"red\"}}/>;\n        case tileType.end: return <td className=\"square\" style={{background: \"orange\"}}/>;\n        default: return <td className=\"square\" style={{background: \"brown\"}}/>;\n    }\n  }\n  \n  class Board extends React.Component {\n    renderSquare(i, j) {\n      return (\n        <Square\n          value={this.props.grid.map[j][i]}\n        />\n      );\n    }\n    \n  \n    render() {\n      return (\n        <div></div>\n      );\n    }\n  }\n\n\n\n  \n  class Game extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        maps: [],\n        pathFound: false,\n        current: 0,\n      };\n      for(let i = 0; i < 5; i++){\n          this.state.maps[i] = {\"map\": new Grid(), \"pathFound\": false};\n      }\n\n      this.findPath = this.findPath.bind(this);\n      this.log = this.log.bind(this);\n      this.nextMap = this.nextMap.bind(this);\n      this.previousMap = this.previousMap.bind(this);\n    }\n\n    findPath() {\n        let current = this.state.current;\n        if (!this.state.maps[current][\"pathFound\"]) {\n            let curMap = this.state.maps[current][\"map\"];\n            let path= aStar(curMap);\n            console.log(path);\n            //console.log(map.start);\n            //console.log(map.end);\n            if(path.length >0){\n                curMap.updateForPath(path);\n                console.log(\"success\");\n                curMap.setPoints();\n                this.state.maps[current][\"pathFound\"] = true;\n                this.setState({pathFound: true});\n            }   \n        }\n    }\n\n    log(){\n        let current = this.state.current;\n        let curMap = this.state.maps[current][\"map\"].map;\n        curMap.printMap();\n    }\n\n    nextMap() {\n        if(this.state.current >=4)\n            this.setState({current: 0})\n        else\n            this.setState({current: (this.state.current+1)})\n\n    }\n\n    previousMap(){\n\n    }\n    \n  \n    render(){\n        let current = this.state.current;\n        let curMap = this.state.maps[current][\"map\"].map;\n        let rows = curMap.map(function (item, i){\n            let entry = item.map(function (element, j) {\n                return ( \n                    Square(element.getType())\n                    );\n            });\n            return (\n                <tr> {entry} </tr>\n            );\n        });\n        return (\n            <div>\n            <button onClick={this.findPath}> Find path</button>\n            <button onClick={this.log}> log</button>\n            <button onClick={this.previousMap}> {'<'} </button>\n            <button onClick={this.nextMap}> {'>'} </button>\n            {'   Map number: '} {this.state.current}\n            <table>\n                {rows}\n            </table>\n            </div>\n        );\n    }\n  }\n  \n  // ========================================\n  \n  ReactDOM.render(<Game />, document.getElementById(\"root\"));\n  \n  \n  ","import { PriorityQueue, QueElement } from \"../dataStructs/priorityQueue\"\nimport { moveCost } from \"../util/weights\"\nimport { Grid } from \"../mapGen/mapGrid\"\nimport { Tile } from \"../mapGen/gridTile\"\nimport { distance } from \"../util/calculations\"\n\n\nexport function aStar(grid:Grid) {\n    let fringe:PriorityQueue = new PriorityQueue();\n    let visited:Tile[] = [];\n    let start:Tile = grid.getStart();\n    let end:Tile = grid.getEnd();\n    let path:Tile[] = [];\n\n    const hVal = function(tile:Tile) :number {\n        return distance(end.getChords(), tile.getChords())\n    }\n\n    fringe.enqueue(start, 0);\n    path.push(start);\n    //console.log(\"beginging search: \" + fringe.que.length);\n    while(!fringe.isEmpty()){\n        let currentTile:QueElement | null = fringe.pop();\n        if(currentTile === null)\n            break;\n        //console.log(\"Starting with fringe[0]\");\n       // console.log(currentTile);\n\n\n        //end condition\n        if(currentTile.element === end){\n           // console.log(\"end condition hit\");\n            while(currentTile.parent !== null){\n                path.push(currentTile.element);\n                currentTile = currentTile.parent;\n            }\n\n            return path.reverse();\n        }\n\n        visited.push(currentTile.element);\n        let neighbors:Tile[] = grid.getNeighbors(currentTile.element.getChords());\n        //console.log(\"got neighbors\");\n        for(let i:number = 0; i < neighbors.length; i++){\n            //console.log(\"checking neighbors\");\n            let neighbor:Tile = neighbors[i];\n            if(visited.indexOf(neighbor) >= 0){\n                continue; // already visited this node\n            }\n\n            let gScore:number = currentTile.g + moveCost(currentTile.element, neighbor);\n\n\n            if(!fringe.inFringe(neighbor)){\n               // console.log(\"Neighbor in fringe\");\n                //must be the new best node\n                let newHVal = hVal(neighbor);\n                let newQueElm = new QueElement(neighbor, 0)\n                newQueElm.h = newHVal;\n                newQueElm.parent = currentTile;\n                newQueElm.g = gScore;\n                newQueElm.f = gScore + newHVal;\n                fringe.addQueElm(newQueElm);\n\n            }\n            else {\n                let oldElm = fringe.getElm(neighbor);\n                if (oldElm !== null && gScore < oldElm.g) {\n                   // console.log(\"found faster path to node\");\n                // already found this node slower so we can update it\n\n                    oldElm.parent = currentTile;\n                    oldElm.g = gScore;\n                    oldElm.f = gScore + oldElm.h;\n                }\n                // otherwise already have it better in the fringe;\n            }\n\n\n        }\n\n\n\n    }\n    console.log(\"failure to find path\")\n    console.log(path);\n    return []; //failure\n\n}"],"sourceRoot":""}